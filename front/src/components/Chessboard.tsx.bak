import React from "react";
import { Chessground } from "chessground";
import ChessgroundTypes from "chessground/types";
import { DrawShape } from "chessground/draw";
import Chess, { ChessInstance, Square } from "chess.js";
import { Row, Col, List } from "antd";
import { observer } from "mobx-react";

import "react-chessground/dist/styles/chessground.css";

type ChessType = (fen?: string) => ChessInstance;

const ChessImport = Chess as unknown;
const Chess2      = ChessImport as ChessType;

interface ChessboardState {
	chess      : ChessInstance,
	tree       : any,
	tree_moves : any,
	moves      : Array<any[]>
}

class Chessboard extends React.Component<object, ChessboardState> {
	private ground_ref = React.createRef<any>();

	private ground:any;

	constructor(props: {}) {
		super(props);

		this.state = {
			chess      : Chess2(),
			tree       : {},
			tree_moves : {},
			moves      : []
		}

		this.renderListMove = this.renderListMove.bind(this);
		this.onMove         = this.onMove.bind(this);
		this.toColor        = this.toColor.bind(this);
		this.toDests        = this.toDests.bind(this);
		this.sizeBoard      = this.sizeBoard.bind(this);
		this.playOtherSide  = this.playOtherSide.bind(this);
	}

	componentDidMount() {		
		let shape:DrawShape = {
			brush : "green",
			dest : "f4",
			orig : "e2"
		};

		const config = {
			movable : {
				color  : this.toColor(),
				free   : false,
				dests  : this.toDests(),
				events : {
					after : this.onMove
				}
			},
			draggable : {
				showGhost : true
			},
			drawable : {
				eraseOnClick : false,
				onChange     : (shape: object) => {
					console.log(shape)
				},
				shapes : [
					shape
				]
			},
			events : {
				insert : this.sizeBoard
			}
		};

		this.ground = Chessground(document.getElementById("chessboard")!, config);

		window.addEventListener("resize", this.sizeBoard);
	}

	render() {
		return (
			<Row gutter={24} style={{ margin: "0 !important" }}>
				<Col className="gutter-row" md={{ span: 8, order : 1 }} xs={{ span : 12, order: 2 }}>
				</Col>
				<Col className="gutter-row" md={{ span: 12, order : 2 }} xs={{ span : 24, order : 1 }}>
					<div id="chessboard" key="chessboard" ref={this.ground_ref}/>
				</Col>
				<Col className="gutter-row" md={{ span: 4, order : 3 }} xs={{ span : 12, order : 3 }}>
					<List
						itemLayout="vertical"
						dataSource={this.state.moves}
						renderItem={this.renderListMove}
					/>
				</Col>
			</Row>
		);
	}

	renderListMove(item: any[], index: number) {
		return (
			<List.Item>
				<Row>
					<Col span={4}>{index + 1}</Col>
					<Col span={10}>{item[0]}</Col>
					<Col span={10}>{(item.length === 2) ? item[1] : ""}</Col>
				</Row>
			</List.Item>
		);
	}

	sizeBoard() {
		const board  = this.ground_ref.current;
		const parent = board.parentElement;
		const width  = parent.clientWidth - (+parent.style.paddingLeft.replace("px", "") * 2) - 0;

		board.style.width = board.style.height = `${width}px`;
	}

	onMove(orig: ChessgroundTypes.Key, dest: ChessgroundTypes.Key, metadata: ChessgroundTypes.MoveMetadata) {
		this.state.chess.move({
			from : orig as Square,
			to   : dest as Square
		});

		this.ground.set({
			check   : this.state.chess.in_check(),
			movable : {
				color : this.toColor(),
				dests : this.toDests()
			}
		});

		const history     = this.state.chess.history();
		const movelist    = history.join(".");
		const move_number = (history.length + 1) / 2.0;
		const move_index  = +Math.floor((history.length - 1) / 2).toFixed(0);

		let tree       = {...this.state.tree};
		let tree_moves = {...this.state.tree_moves};
		let moves      = [...this.state.moves];

		if (!tree[movelist]) {
			tree[movelist] = {
				movelist : movelist,
				move     : move_number,
				sort     : (Array.isArray(tree_moves[move_number])) ? tree_moves[move_number].length : 0,
				children : 0
			};
		}

		if (!tree_moves[move_number]) {
			tree_moves[move_number] = [];
		}

		if (!tree_moves[move_number].includes(movelist)) {
			tree_moves[move_number].push(movelist);
		}

		if (!moves[move_index]) {
			moves.push([]);
		}

		moves[move_index].push(history.at(-1));

		this.setState({
			chess : this.state.chess,

			tree,
			tree_moves,
			moves
		});
	}

	toColor(): ChessgroundTypes.Color {
		return (this.state.chess.turn() === "w") ? "white" : "black";
	}

	toDests() {
		const dests = new Map();

		this.state.chess.SQUARES.forEach(s => {
			const ms = this.state.chess.moves({
				square  : s,
				verbose : true
			});

			if (ms.length) {
				dests.set(s, ms.map(m => m.to));
			}
		});

		return dests;
	}

	playOtherSide() {
		return (orig: Square, dest: Square) => {
			console.log(dest);
			// Update chess.js
			// Note: we don't check the return value here which would tell
			// us if this is a legal move.  That's because we only allowed legal moves by setting "dests"
			// on the board.
			this.state.chess.move({
				from : orig, 
				to   : dest
			});
			
			this.ground.set({
				// I'm not sure what this does! You can comment it out and not much changes
				// turnColor: toColor(chess),
				
				// this highlights the checked king in red
				check   : this.state.chess.in_check(),
				movable : {
					// Only allow moves by whoevers turn it is
					color : this.toColor(),
					
					// Only allow legal moves
					dests : this.toDests()
				}
			});
		};
	}
}

export default observer(Chessboard);